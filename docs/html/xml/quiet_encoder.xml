<?xml version='1.0' encoding='utf-8'?>
<typedef id="quiet_encoder" name="quiet_encoder" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <type name="quiet_encoder" ref="quiet_encoder#quiet_encoder" />
  <function id="quiet_encoder_clamp_frame_len" name="quiet_encoder_clamp_frame_len">
    <brief> Clamp frame length to largest possible for sample length</brief>
    <doc>quiet_encoder_clamp_frame_len enables a mode in the encoder which prevents
data frames from overlapping multiple blocks of samples, e.g. multiple calls
to quiet_encoder_emit. This can be very convenient if your environment
cannot keep up in realtime due to e.g. GC pauses. The transmission of data
will succeed as long as the blocks of samples are played out smoothly (gaps
between blocks are ok, gaps within blocks are not ok).

Calling this with the size of your sample block will clamp the frame length
of this encoder and toggle the `is_close_frame` flag which will ensure that
sample blocks will always end in silence. This will never result in a frame
length longer than the one provided in the creation of the encoder, but it
may result in a shorter frame length.

</doc>
    <return>
      <doc>the new frame length</doc>
      <type name="size_t" />
    </return>
    <argument id="quiet_encoder_clamp_frame_len::e" name="e">
      <doc>encoder object</doc>
      <type name="quiet_encoder" qualifier="*" ref="quiet_encoder#quiet_encoder" />
    </argument>
    <argument id="quiet_encoder_clamp_frame_len::sample_len" name="sample_len">
      <doc>size of sample block</doc>
      <type name="size_t" />
    </argument>
  </function>
  <function id="quiet_encoder_create" name="quiet_encoder_create">
    <brief> Create encoder</brief>
    <doc>quiet_encoder_create creates and initializes a new libquiet encoder for a
given set of options and sample rate. As libquiet makes use of its own
resampler, it is suggested to use the default sample rate of your device,
so as to not invoke any implicit resamplers.

</doc>
    <return>
      <doc>pointer to a new encoder object, or NULL if creation failed</doc>
      <type name="quiet_encoder" qualifier="*" ref="quiet_encoder#quiet_encoder" />
    </return>
    <argument id="quiet_encoder_create::opt" name="opt">
      <doc>quiet_encoder_options containing encoder configuration</doc>
      <type name="quiet_encoder_options" qualifier=" const *" ref="options::quiet_encoder_options#options::quiet_encoder_options" />
    </argument>
    <argument id="quiet_encoder_create::sample_rate" name="sample_rate">
      <doc>Sample rate that encoder will generate at</doc>
      <type builtin="yes" name="float" />
    </argument>
  </function>
  <function id="quiet_encoder_destroy" name="quiet_encoder_destroy">
    <brief> Destroy encoder</brief>
    <doc>quiet_encoder_destroy releases all resources allocated by the quiet_encoder.
After calling this function, the user should not call any other encoder
functions on the quiet_encoder.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="quiet_encoder_destroy::e" name="e">
      <doc>encoder object</doc>
      <type name="quiet_encoder" qualifier="*" ref="quiet_encoder#quiet_encoder" />
    </argument>
  </function>
  <function id="quiet_encoder_emit" name="quiet_encoder_emit">
    <brief> Emit samples</brief>
    <doc>quiet_encoder_emit fills a block of samples pointed to by samplebuf by
reading frames from its transmit queue and encoding them into sound by using
the configuration specified at creation. These samples can be written out
directly to a file or soundcard.

If you are using a soundcard, it is recommended to use the largest block
size offered. Typically, this is 16384 samples. Larger block sizes will
help hide uneven latencies in the encoding process and ensure smoother
transmission at the cost of longer latencies.

</doc>
    <return>
      <doc>the number of samples written to samplebuf, which shall never
 exceed samplebuf_len. If the returned number of samples written is less
 than samplebuf_len, then the encoder has finished encoding the payload
 (its transmit queue is empty and all state has been flushed out). The user
 should 0-fill any remaining length if the block is to be transmitted.</doc>
      <type name="size_t" />
    </return>
    <argument id="quiet_encoder_emit::e" name="e">
      <doc>encoder object</doc>
      <type name="quiet_encoder" qualifier="*" ref="quiet_encoder#quiet_encoder" />
    </argument>
    <argument id="quiet_encoder_emit::samplebuf" name="samplebuf">
      <doc>user-provided array where samples will be written</doc>
      <type name="quiet_sample_t" qualifier="*" ref="index#quiet_sample_t" />
    </argument>
    <argument id="quiet_encoder_emit::samplebuf_len" name="samplebuf_len">
      <doc>length of user-provided array</doc>
      <type name="size_t" />
    </argument>
  </function>
  <function id="quiet_encoder_get_frame_len" name="quiet_encoder_get_frame_len">
    <brief> Retrieve encoder frame length</brief>
    <return>
      <doc>encoder's maximum frame length, e.g. the largest length that can
 be passed to quiet_encoder_send</doc>
      <type name="size_t" />
    </return>
    <argument id="quiet_encoder_get_frame_len::e" name="e">
      <doc>encoder object</doc>
      <type name="quiet_encoder" qualifier=" const *" ref="quiet_encoder#quiet_encoder" />
    </argument>
  </function>
  <function id="quiet_encoder_send" name="quiet_encoder_send">
    <brief> Send a single frame</brief>
    <doc>quiet_encoder_send copies the frame provided by the user to an internal
transmit queue. This is a nonblocking call and will fail if the queue is
full.

The frame provided must be no longer than the maximum frame length of the
encoder. If the frame is longer, it will be rejected entirely, and no data
will be transmitted.

</doc>
    <return>
      <doc>the number of bytes copied from the buffer, or -1 if sending failed</doc>
      <type name="ssize_t" />
    </return>
    <argument id="quiet_encoder_send::e" name="e">
      <doc>encoder object</doc>
      <type name="quiet_encoder" qualifier="*" ref="quiet_encoder#quiet_encoder" />
    </argument>
    <argument id="quiet_encoder_send::buf" name="buf">
      <doc>user buffer containing the frame payload</doc>
      <type builtin="yes" name="void" qualifier=" const *" />
    </argument>
    <argument id="quiet_encoder_send::len" name="len">
      <doc>the number of bytes in buf</doc>
      <type name="size_t" />
    </argument>
  </function>
</typedef>
