<?xml version='1.0' encoding='utf-8'?>
<typedef id="quiet_decoder" name="quiet_decoder" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <type name="quiet_decoder" ref="quiet_decoder#quiet_decoder" />
  <function id="quiet_decoder_checksum_fails" name="quiet_decoder_checksum_fails">
    <brief> Return number of failed frames</brief>
    <doc>quiet_decoder_checksum_fails returns the total number of frames decoded
but which failed checksum across the lifetime of the decoder.

</doc>
    <return>
      <doc>Total number of frames received with failed checksums</doc>
      <type builtin="yes" name="unsigned int" />
    </return>
    <argument id="quiet_decoder_checksum_fails::d" name="d">
      <doc>decoder object</doc>
      <type name="quiet_decoder" qualifier=" const *" ref="quiet_decoder#quiet_decoder" />
    </argument>
  </function>
  <function id="quiet_decoder_consume" name="quiet_decoder_consume">
    <brief> Feed received sound samples to decoder</brief>
    <doc>quiet_decoder_consume consumes sound samples and decodes them to frames.
These can be samples obtained directly from a sound file, a soundcard's
microphone, or any other source which can receive quiet_sample_t (float).

If you are using a soundcard, it is recommended to use the largest block
size offered. Typically, this is 16384 samples. Larger block sizes will
help hide uneven latencies in the decoding process and ensure smoother
reception at the cost of longer latencies.

</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="quiet_decoder_consume::d" name="d">
      <doc>decoder object</doc>
      <type name="quiet_decoder" qualifier="*" ref="quiet_decoder#quiet_decoder" />
    </argument>
    <argument id="quiet_decoder_consume::samplebuf" name="samplebuf">
      <doc>array of samples received from sound card</doc>
      <type name="quiet_sample_t" qualifier=" const *" ref="index#quiet_sample_t" />
    </argument>
    <argument id="quiet_decoder_consume::sample_len" name="sample_len">
      <doc>number of samples in samplebuf</doc>
      <type name="size_t" />
    </argument>
  </function>
  <function id="quiet_decoder_create" name="quiet_decoder_create">
    <brief> Create decoder</brief>
    <doc>quiet_decoder_create creates and initializes a new libquiet decoder for a
given set of options and sample rate.

It is recommended to use the default sample rate of your device in order
to avoid any possible implicit resampling, which can distort samples.

</doc>
    <return>
      <doc>pointer to new decoder object, or NULL if creation failed.</doc>
      <type name="quiet_decoder" qualifier="*" ref="quiet_decoder#quiet_decoder" />
    </return>
    <argument id="quiet_decoder_create::opt" name="opt">
      <doc>quiet_decoder_options containing decoder configuration</doc>
      <type name="quiet_decoder_options" qualifier=" const *" ref="options::quiet_decoder_options#options::quiet_decoder_options" />
    </argument>
    <argument id="quiet_decoder_create::sample_rate" name="sample_rate">
      <doc>Sample rate that decoder will consume at</doc>
      <type builtin="yes" name="float" />
    </argument>
  </function>
  <function id="quiet_decoder_destroy" name="quiet_decoder_destroy">
    <brief> Destroy decoder</brief>
    <doc>quiet_decoder_destroy releases all resources allocated by the quiet_decoder.
After calling this function, the user should not call any other decoder
functions on the decoder.
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="quiet_decoder_destroy::d" name="d">
      <doc>decoder object</doc>
      <type name="quiet_decoder" qualifier="*" ref="quiet_decoder#quiet_decoder" />
    </argument>
  </function>
  <function id="quiet_decoder_flush" name="quiet_decoder_flush">
    <brief> Flush existing state through decoder</brief>
    <doc>quiet_decoder_flush empties out all internal buffers and attempts to decode
them

This function need only be called after the sound stream has stopped.
It is especially useful for reading from sound files where there are no
trailing samples to "push" the decoded data through the decoder's filters
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="quiet_decoder_flush::d" name="d">
      <doc>decoder object</doc>
      <type name="quiet_decoder" qualifier="*" ref="quiet_decoder#quiet_decoder" />
    </argument>
  </function>
  <function id="quiet_decoder_recv" name="quiet_decoder_recv">
    <brief> Try to receive a single frame</brief>
    <doc>quiet_decoder_recv reads one frame from the decoder's receive buffer. This
is a nonblocking call and will fail quickly if no frames are ready to
be received.

If the user's supplied buffer is smaller than the length of the received
frame, then only `len` bytes will be copied to `data`. The remaining bytes
will be discarded.

This function will never return frames for which the checksum has failed.

</doc>
    <return>
      <doc>number of bytes written to buffer, -1 if no frames available</doc>
      <type name="ssize_t" />
    </return>
    <argument id="quiet_decoder_recv::d" name="d">
      <doc>decoder object</doc>
      <type name="quiet_decoder" qualifier="*" ref="quiet_decoder#quiet_decoder" />
    </argument>
    <argument id="quiet_decoder_recv::data" name="data">
      <doc>user buffer which quiet will write received frame into</doc>
      <type name="uint8_t" qualifier="*" />
    </argument>
    <argument id="quiet_decoder_recv::len" name="len">
      <doc>length of user-supplied buffer</doc>
      <type name="size_t" />
    </argument>
  </function>
</typedef>
